# Search-Core 코드 흐름 및 데이터 구조

## 전체 실행 흐름

```
[main.rs]
  │
  ├─ tokio::main 초기화
  │
  └─ repls::run_repl().await
       │
       ├─ 무한 루프 시작
       │
       ├─ 프롬프트 출력: "> "
       │
       ├─ 사용자 입력 읽기
       │
       ├─ Command::parse(input)
       │   │
       │   ├─ "quit" → Command::Quit
       │   ├─ "help" → Command::Help
       │   └─ 그 외 → Command::Search { pattern, path }
       │
       └─ 명령어별 처리
           │
           ├─ Search:
           │   │
           │   ├─ search_dir::search_stream() 호출
           │   │   │
           │   │   ├─ mpsc::channel(1000) 생성
           │   │   │
           │   │   ├─ Arc로 pattern, options 래핑
           │   │   │
           │   │   └─ spawn_blocking으로 백그라운드 태스크 시작
           │   │       │
           │   │       └─ WalkBuilder::new()
           │   │           │
           │   │           ├─ .hidden() 설정
           │   │           ├─ .threads(num_cpus::get())
           │   │           └─ .build_parallel()
           │   │               │
           │   │               └─ 각 워커 스레드에서:
           │   │                   │
           │   │                   ├─ 파일 발견 시
           │   │                   │   │
           │   │                   └─ searcher::searcher() 호출
           │   │                       │
           │   │                       ├─ File::open()
           │   │                       ├─ Mmap::map() (메모리 매핑)
           │   │                       ├─ matcher::find_matches()
           │   │                       │   │
           │   │                       │   └─ memmem::Finder로 SIMD 검색
           │   │                       │
           │   │                       └─ 각 매치에 대해:
           │   │                           │
           │   │                           ├─ matcher::extract_line_context()
           │   │                           │   │
           │   │                           │   ├─ memrchr로 줄 시작 찾기
           │   │                           │   ├─ memchr로 줄 끝 찾기
           │   │                           │   ├─ 줄 번호 계산
           │   │                           │   └─ 컬럼 계산 (UTF-8)
           │   │                           │
           │   │                           └─ MatchInfo 생성
           │   │                               │
           │   │                               └─ tx.send(Ok(info))
           │   │
           │   └─ ReceiverStream 반환
           │       │
           │       └─ REPL에서 stream.next().await로 소비
           │           │
           │           ├─ Ok(info) → println!("{}", info)
           │           └─ Err(e) → eprintln!("Error: {}", e)
           │
           ├─ Help: 도움말 출력
           │
           ├─ Quit: 루프 종료
           │
           └─ Invalid: 에러 메시지 출력
```

## 데이터 구조 변환 흐름

### 1. 사용자 입력 → Command
```
String: "rust ."
  ↓
Command::parse()
  ↓
Command::Search {
    pattern: "rust",
    path: "."
}
```

### 2. Command → 검색 실행
```
Command::Search { pattern, path }
  ↓
search_stream(root, pattern, options)
  ↓
ReceiverStream<Result<MatchInfo>>
```

### 3. 파일 검색 과정
```
PathBuf: "test_data/sample1.txt"
  ↓
File::open()
  ↓
Mmap (메모리 매핑된 바이트 배열)
  ↓
matcher::find_matches(&mmap, pattern_bytes)
  ↓
Vec<usize>: [20, 45, 67]  (바이트 오프셋)
  ↓
각 오프셋에 대해 extract_line_context()
  ↓
(usize, usize, (usize, usize)): (line, column, (start, end))
  ↓
MatchInfo 생성
  ↓
Vec<MatchInfo>
```

### 4. MatchInfo 구조
```
MatchInfo {
    path: PathBuf("test_data/sample1.txt"),
    line_number: 3,
    column: 20,
    byte_offset: 45,
    matched_text: Arc<String>("rust"),
    line_range: (30, 60)
}
  ↓
Display 트레이트로 포맷팅
  ↓
String: "test_data/sample1.txt:3:20  'rust'"
```

## 동시성 모델

### 스레드 구조
```
[메인 스레드: Tokio Runtime]
  │
  ├─ REPL 루프 (비동기)
  │   │
  │   └─ stream.next().await (비동기 대기)
  │
  └─ [블로킹 스레드 풀]
      │
      └─ spawn_blocking 태스크
          │
          └─ [워커 스레드 1] ──┐
          └─ [워커 스레드 2] ──┤
          └─ [워커 스레드 3] ──┼──→ [mpsc::channel] ─→ [ReceiverStream]
          └─ [워커 스레드 N] ──┘
```

### 채널 통신
```
[워커 스레드들] (생산자)
  │
  │ tx.send(Ok(MatchInfo))
  │ tx.send(Ok(MatchInfo))
  │ tx.send(Err(Error))
  ↓
[mpsc::channel] (버퍼 크기: 1000)
  ↓
[ReceiverStream] (소비자)
  ↓
[REPL: stream.next().await]
```

## 메모리 레이아웃

### Arc<String> 공유
```
[Arc<String> 패턴]
  │
  ├─ [워커 스레드 1] ──┐
  ├─ [워커 스레드 2] ──┤──→ 동일 메모리 참조
  └─ [워커 스레드 N] ──┘
```

### 메모리 매핑
```
[디스크 파일]
  │
  └─ OS 가상 메모리 매핑
      │
      └─ [Mmap] (프로세스 가상 주소 공간)
          │
          └─ Zero-copy 접근
```

## 에러 전파 경로

### 파일 읽기 실패
```
searcher::searcher()
  │
  ├─ File::open() → Error
  │   │
  │   └─ return Err(anyhow::Error)
  │
  └─ Mmap::map() → Error
      │
      └─ return Err(anyhow::Error)
  ↓
search_dir::search_stream() 워커
  │
  └─ tx.send(Err(anyhow::Error))
  ↓
ReceiverStream
  ↓
REPL: stream.next().await
  │
  └─ Err(e) → eprintln!("Error: {}", e)
```

### 채널 닫힘 처리
```
[워커 스레드]
  │
  └─ tx.send(Ok(info))
      │
      └─ Err(SendError) → 채널 닫힘
          │
          └─ return WalkState::Quit
```

## 성능 최적화 포인트

### 1. SIMD 가속
```
[바이트 배열: target]
  │
  └─ memmem::Finder::new(pattern)
      │
      └─ SIMD 명령어 (SSE/AVX)
          │
          └─ 벡터화된 패턴 검색
              │
              └─ [매치 위치들]
```

### 2. 병렬 파일 순회
```
[WalkBuilder]
  │
  ├─ [워커 1] → 파일 A 검색
  ├─ [워커 2] → 파일 B 검색
  ├─ [워커 3] → 파일 C 검색
  └─ [워커 4] → 파일 D 검색
      │
      └─ 동시에 채널로 전송
```

### 3. 스트리밍 출력
```
[매치 발견 즉시]
  │
  └─ 채널로 전송
      │
      └─ REPL에서 즉시 출력
          │
          └─ 사용자가 실시간으로 결과 확인
```

## 타입 변환 체인

### 바이트 → 텍스트
```
&[u8] (파일 내용)
  ↓
Mmap (메모리 매핑)
  ↓
&[u8] (패턴 검색)
  ↓
usize (바이트 오프셋)
  ↓
extract_line_context()
  ↓
String::from_utf8_lossy() (UTF-8 디코딩)
  ↓
chars().count() (문자 개수)
  ↓
MatchInfo (구조화된 데이터)
  ↓
Display::fmt() (포맷팅)
  ↓
String (최종 출력)
```

## 상태 머신 (REPL)

```
[시작]
  │
  └─ [대기 상태]
      │
      ├─ 입력: "pattern path"
      │   │
      │   └─ [검색 실행 상태]
      │       │
      │       ├─ 스트림 소비 중
      │       │
      │       └─ 완료 → [대기 상태]
      │
      ├─ 입력: "help"
      │   │
      │   └─ 도움말 출력 → [대기 상태]
      │
      └─ 입력: "quit"
          │
          └─ [종료]
```