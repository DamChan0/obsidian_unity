# Search-Core 모듈 상세 분석

## 1. types.rs - 타입 시스템

### SearchOptions
```rust
pub struct SearchOptions {
    pub case_insensitive: bool,  // 대소문자 무시 (현재 미구현)
    pub include_hidden: bool,     // 숨김 파일 포함
}
```

**역할**: 검색 동작을 제어하는 옵션
**특징**: `Default` 트레이트로 기본값 제공 (둘 다 `false`)

### MatchInfo
```rust
pub struct MatchInfo {
    pub path: PathBuf,
    pub line_number: usize,      // 1-based
    pub column: usize,           // 1-based, UTF-8 문자 기준
    pub byte_offset: usize,
    pub matched_text: Arc<String>, // 공유 소유권으로 메모리 효율
    pub line_range: (usize, usize), // (시작 바이트, 끝 바이트)
}
```

**메모리 최적화**: `matched_text`를 `Arc<String>`으로 사용하여 동일 패턴 검색 시 메모리 공유

**메서드 분석**:
- `make_pattern_link()`: `path:line:column` 형식 (에디터 링크)
- `make_location()`: `line:column` 형식
- `get_line_text()`: 메모리 매핑으로 줄 텍스트 읽기
- `highlighted_line()`: `colored` 크레이트로 하이라이트

## 2. matcher.rs - 패턴 매칭 엔진

### find_matches()
```rust
pub fn find_matches(target: &[u8], pattern: &[u8]) -> Vec<usize>
```

**구현**:
- `memmem::Finder::new(pattern)`: SIMD 최적화된 패턴 검색기 생성
- `finder.find_iter(target)`: 반복자로 모든 매치 위치 반환
- 빈 패턴 체크로 안전성 보장

**성능**: SIMD 명령어로 벡터화된 검색 (x86-64의 SSE/AVX 활용)

### extract_line_context()
```rust
pub fn extract_line_context(data: &[u8], pos: usize) -> (usize, usize, (usize, usize))
```

**알고리즘**:
1. **줄 시작 찾기**: `memrchr(b'\n', &data[..pos])`
   - 역방향 검색으로 현재 위치 이전의 마지막 줄바꿈 찾기
   - 없으면 0 (파일 시작)
   
2. **줄 끝 찾기**: `memchr(b'\n', &data[pos..])`
   - 현재 위치 이후의 첫 줄바꿈 찾기
   - 없으면 파일 끝
   
3. **줄 번호 계산**: `bytecount::count(&data[..line_start], b'\n') + 1`
   - 줄바꿈 개수 + 1 (1-based)
   
4. **컬럼 계산**: UTF-8 디코딩 후 문자 개수
   - `String::from_utf8_lossy()`로 바이트를 문자로 변환
   - `chars().count()`로 실제 문자 개수 계산

**주의사항**: UTF-8 멀티바이트 문자를 올바르게 처리

## 3. searcher.rs - 파일 검색

### searcher()
```rust
pub fn searcher(
    path: &Path,
    pattern: Arc<String>,
    _options: &SearchOptions,
) -> Result<Vec<MatchInfo>>
```

**처리 흐름**:
1. 파일 열기 및 빈 파일 체크
2. 메모리 매핑 (`unsafe { Mmap::map(&file)? }`)
   - OS 레벨에서 파일을 가상 메모리에 매핑
   - 실제 메모리 복사 없이 접근
3. 패턴을 바이트로 변환
4. `matcher::find_matches()`로 매치 위치 찾기
5. 각 위치에 대해 `extract_line_context()` 호출
6. `MatchInfo` 벡터 생성

**메모리 효율성**:
- `Vec::with_capacity()`로 사전 할당
- `Arc::clone()`으로 패턴 공유 (복사 없음)

**안전성**: `unsafe` 블록은 `memmap2` 크레이트가 보장하는 안전한 사용

## 4. search_dir.rs - 디렉토리 검색

### search_stream()
```rust
pub fn search_stream(
    root: &Path,
    pattern: &str,
    options: SearchOptions,
) -> ReceiverStream<Result<MatchInfo>>
```

**아키텍처**:
```
[REPL] ←─── ReceiverStream ←─── mpsc::channel ←─── [백그라운드 스레드들]
                                                          ↓
                                                    [WalkBuilder]
                                                          ↓
                                                    [각 파일 검색]
```

**구현 세부**:
1. **채널 생성**: `mpsc::channel(1000)` - 버퍼 크기 1000
2. **Arc로 공유**: `pattern`과 `options`를 Arc로 래핑
3. **블로킹 태스크**: `spawn_blocking`으로 파일 시스템 작업 격리
4. **WalkBuilder 설정**:
   - `hidden()`: 숨김 파일 필터링
   - `threads(num_cpus::get())`: CPU 코어 수만큼 스레드
   - `build_parallel()`: 병렬 순회 모드
5. **워커 클로저**: 각 스레드에서 실행되는 클로저
   - 파일 타입 체크 (`is_file()`)
   - `searcher::searcher()` 호출
   - 결과를 채널로 전송
   - 에러 처리 및 채널 닫힘 감지

**동시성 모델**:
- **생산자**: 여러 워커 스레드 (병렬 파일 순회)
- **소비자**: REPL의 비동기 스트림
- **통신**: 단일 채널로 멀티프로듀서 패턴

**에러 처리**:
- 파일 읽기 실패: 에러를 채널로 전송하고 계속 진행
- 채널 닫힘: `WalkState::Quit` 반환하여 순회 중단

## 5. command.rs - 명령어 파싱

### Command enum
```rust
pub enum Command {
    Search { pattern: String, path: String },
    Quit,
    Help,
    Invalid(String),
}
```

### parse() 메서드
**파싱 규칙**:
1. 빈 입력 → `Invalid("empty input")`
2. `"quit" | "q" | "exit"` → `Quit`
3. `"help" | "h"` → `Help`
4. 그 외 → `Search { pattern, path }`
   - 첫 번째 단어: 패턴
   - 두 번째 단어: 경로 (없으면 `"."`)

**특징**: 간단한 문자열 분할로 구현 (복잡한 파서 불필요)

## 6. repls.rs - REPL 인터페이스

### run_repl()
**구조**:
```rust
loop {
    1. 프롬프트 출력 및 flush
    2. 사용자 입력 읽기
    3. Command 파싱
    4. 명령어별 처리:
       - Search: search_stream() 생성 및 소비
       - Help: 도움말 출력
       - Quit: 루프 종료
       - Invalid: 에러 메시지
}
```

**스트림 처리**:
```rust
let mut stream = search_stream(&rootpath, &pattern, options.clone());
let mut count = 0;
while let Some(result) = stream.next().await {
    match result {
        Ok(info) => {
            count += 1;
            println!("{}", info);  // Display 트레이트 활용
        }
        Err(e) => eprintln!("Error: {}", e),
    }
}
println!("✅ 완료: 총 {}건 발견\n", count);
```

**특징**:
- 실시간 결과 출력 (스트리밍)
- 결과 카운팅
- 에러 처리 및 사용자 피드백

## 7. 메모리 관리 전략

### Arc 사용 이유
1. **pattern**: 여러 스레드에서 동일 패턴 공유
2. **matched_text**: 동일 패턴 검색 시 메모리 절약

### 메모리 매핑
- **장점**: Zero-copy, OS 캐싱 활용
- **단점**: 큰 파일의 경우 가상 메모리 압박 가능
- **해결**: OS가 필요시 페이징 처리

### 벡터 사전 할당
- `Vec::with_capacity(match_indices.len())`: 재할당 방지

## 8. 에러 처리 전략

### anyhow::Result
- **장점**: 컨텍스트 추가 용이, 에러 체인 자동 생성
- **사용 위치**: 파일 I/O, 메모리 매핑

### 채널 에러 전파
- 파일 읽기 실패: `tx.send(Err(...))`로 전송
- 채널 닫힘: `WalkState::Quit` 반환

## 9. 성능 최적화 포인트

1. **SIMD 가속**: `memchr`/`memmem`의 벡터화
2. **병렬 처리**: CPU 코어 수만큼 워커 스레드
3. **Zero-copy**: 메모리 매핑으로 복사 제거
4. **스트리밍**: 결과 즉시 출력으로 지연 최소화
5. **메모리 효율**: Arc로 중복 데이터 방지

## 10. 개선 가능한 부분

### 현재 미구현
- `case_insensitive` 옵션: 패턴과 대상 모두 소문자 변환 필요
- 정규식 지원: `regex` 크레이트 통합 필요

### 최적화 여지
- 큰 파일 처리: 청크 단위 메모리 매핑
- 결과 정렬: 스트림 수집 후 정렬 옵션
- 컨텍스트 라인: 매치 전후 N줄 표시

### 안전성 개선
- `unwrap()` 제거: `repls.rs`의 `flush().unwrap()` → 에러 처리
- 타임아웃: 장시간 실행 방지를 위한 타임아웃