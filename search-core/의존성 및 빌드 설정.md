# Search-Core 의존성 및 빌드 설정

## Cargo.toml 분석

### 프로젝트 메타데이터
```toml
[package]
name = "search-core"
version = "0.1.0"
edition = "2024"  # 최신 Rust 에디션
```

### 빌드 프로파일

#### 개발 모드 (기본)
```toml
[profile.dev]
opt-level = 0      # 내 코드는 최적화 끄기 (디버깅 용이)
debug = true       # 디버그 정보 포함

[profile.dev.package."*"]
opt-level = 3      # 외부 라이브러리는 최고 속도로 최적화
```

**설계 의도**:
- 개발 중에는 내 코드를 최적화하지 않아 디버깅이 쉬움
- 외부 라이브러리(특히 SIMD 가속 라이브러리)는 최적화하여 성능 확보

#### 릴리즈 모드 (기본값 사용)
- `opt-level = 3`: 최고 수준 최적화
- `lto = false`: 링크 타임 최적화 비활성화 (빌드 시간 단축)
- `codegen-units = 16`: 병렬 코드 생성

### 바이너리 설정
```toml
[[bin]]
name = "search-core"
path = "src/main.rs"
```

### 라이브러리 설정
```toml
[lib]
name = "search_core"
path = "src/lib.rs"
```

## 의존성 분석

### 비동기 런타임
```toml
tokio = { version = "1", features = ["full"] }
```
- **역할**: 비동기 런타임 제공
- **features**: `["full"]` - 모든 기능 활성화
  - `rt-multi-thread`: 멀티스레드 스케줄러
  - `io-util`: I/O 유틸리티
  - `sync`: 동기화 프리미티브
  - `time`: 타이머 기능
- **사용 위치**: `main.rs` (진입점), `search_dir.rs` (채널, 스트림)

### 스트림 처리
```toml
futures = "0.3"
tokio-stream = "0.1"
```
- **futures**: `StreamExt` 트레이트 (`.next()` 메서드)
- **tokio-stream**: `ReceiverStream` 래퍼
- **사용 위치**: `repls.rs` (스트림 소비), `search_dir.rs` (스트림 생성)

### 파일 시스템
```toml
walkdir = "2"
ignore = "0.4"
```
- **walkdir**: 기본 디렉토리 순회 (사용 안 함, ignore로 대체)
- **ignore**: ripgrep 기반 병렬 파일 순회
  - `.gitignore` 자동 인식
  - 병렬 처리 지원
  - 숨김 파일 필터링
- **사용 위치**: `search_dir.rs`

### 메모리 매핑 및 검색
```toml
memmap2 = "0.9"
memchr = "2.7"
bytecount = "0.6.9"
```
- **memmap2**: 메모리 매핑 (Zero-copy 파일 읽기)
  - `Mmap::map()`: 파일을 가상 메모리에 매핑
- **memchr**: SIMD 가속 바이트 검색
  - `memchr()`: 단일 바이트 검색
  - `memrchr()`: 역방향 단일 바이트 검색
  - `memmem::Finder`: 멀티바이트 패턴 검색 (SIMD)
- **bytecount**: 효율적인 바이트 카운팅
  - `count()`: 특정 바이트의 개수 세기
- **사용 위치**: `searcher.rs`, `matcher.rs`

### 에러 처리
```toml
anyhow = "1.0"
```
- **역할**: 컨텍스트 기반 에러 처리
- **특징**: `Result<T, anyhow::Error>`로 통일
- **사용 위치**: 모든 모듈

### 유틸리티
```toml
colored = "3"
clap = { version = "4", features = ["derive"] }
num_cpus = "1.0"
```
- **colored**: 터미널 색상 출력
  - `Colorize` 트레이트: `.purple()`, `.bold()` 등
- **clap**: CLI 인자 파싱 (현재 미사용, 향후 확장용)
- **num_cpus**: CPU 코어 수 확인
  - `num_cpus::get()`: 논리 코어 수 반환
- **사용 위치**: `types.rs` (colored), `search_dir.rs` (num_cpus)

## 의존성 트리 (주요)

```
search-core
├── tokio (비동기 런타임)
│   ├── tokio-macros
│   ├── tokio-util
│   └── ...
├── futures (스트림 트레이트)
├── tokio-stream (스트림 유틸리티)
│   └── tokio
├── ignore (파일 순회)
│   ├── crossbeam-channel
│   ├── globset
│   └── ...
├── memmap2 (메모리 매핑)
│   └── libc
├── memchr (SIMD 검색)
│   └── (SIMD 최적화)
├── anyhow (에러 처리)
└── ...
```

## 빌드 명령어

### 개발 빌드
```bash
cargo build
# 또는
cargo build --dev
```

**결과물**: `target/debug/search-core.exe`

### 릴리즈 빌드
```bash
cargo build --release
```

**결과물**: `target/release/search-core.exe`
- 최적화된 바이너리
- 디버그 정보 제거
- 더 작은 크기, 더 빠른 실행

### 실행
```bash
# 개발 모드
cargo run

# 릴리즈 모드
cargo run --release
```

### 테스트
```bash
cargo test
```

### 린팅 및 포맷팅
```bash
# 코드 포맷팅
cargo fmt

# 린터 실행
cargo clippy

# 린터 (경고를 에러로 처리)
cargo clippy -- -D warnings
```

## 최적화 전략

### 컴파일 타임 최적화
1. **외부 라이브러리 최적화**: `opt-level = 3` (SIMD 라이브러리 성능 확보)
2. **내 코드 디버깅 용이**: `opt-level = 0` (개발 중)

### 런타임 최적화
1. **SIMD 가속**: `memchr`/`memmem`의 벡터화
2. **병렬 처리**: CPU 코어 수만큼 워커 스레드
3. **Zero-copy**: 메모리 매핑으로 복사 제거
4. **스트리밍**: 결과 즉시 출력

## 의존성 선택 이유

### tokio vs async-std
- **선택**: tokio
- **이유**: 더 넓은 생태계, 더 나은 성능, 더 많은 기능

### ignore vs walkdir
- **선택**: ignore
- **이유**: ripgrep 기반으로 검증된 성능, 병렬 처리 내장, `.gitignore` 지원

### memmap2 vs 다른 메모리 매핑 라이브러리
- **선택**: memmap2
- **이유**: `memmap`의 후속 버전, 더 나은 안전성, 활발한 유지보수

### memchr vs regex
- **선택**: memchr
- **이유**: 단순 패턴 검색에 최적화, SIMD 가속, 더 빠른 성능

## 보안 고려사항

### 메모리 매핑
- `unsafe` 블록 사용: `memmap2` 크레이트가 안전성 보장
- 큰 파일 처리: OS가 페이징으로 관리

### 입력 검증
- 현재: 기본적인 경로 검증
- 개선 필요: 경로 순회 공격 방지, 심볼릭 링크 처리

## 성능 벤치마크

### 예상 성능 (개발 모드)
- 작은 파일 (< 1MB): 즉시 결과
- 중간 파일 (1-10MB): 수백 ms
- 큰 파일 (> 100MB): 수 초

### 예상 성능 (릴리즈 모드)
- 작은 파일: 즉시 결과
- 중간 파일: 수십 ms
- 큰 파일: 수백 ms

## 향후 개선 사항

### 의존성 추가 고려
- `regex`: 정규식 패턴 지원
- `rayon`: 데이터 병렬 처리 (대안)
- `tracing`: 구조화된 로깅
- `serde`: 설정 파일 직렬화

### 빌드 최적화
- `lto = "thin"`: 링크 타임 최적화 (빌드 시간 vs 성능 트레이드오프)
- `codegen-units = 1`: 단일 코드 생성 단위 (최대 최적화)
- `panic = "abort"`: 패닉 시 즉시 종료 (바이너리 크기 감소)