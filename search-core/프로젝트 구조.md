# Search-Core 프로젝트 구조

## 개요
`search-core`는 Rust로 구현된 고성능 파일 검색 엔진입니다. 메모리 매핑과 SIMD 가속을 활용하여 빠른 텍스트 검색을 제공하며, 비동기 스트림 기반으로 실시간 결과를 출력합니다.

## 프로젝트 정보
- **이름**: search-core
- **버전**: 0.1.0
- **언어**: Rust (Edition 2024)
- **런타임**: Tokio (비동기)

## 디렉토리 구조

```
search-core/
├── src/
│   ├── main.rs          # 프로그램 진입점 (REPL 실행)
│   ├── lib.rs           # 라이브러리 진입점 (모듈 export)
│   ├── types.rs         # 타입 정의 (MatchInfo, SearchOptions)
│   ├── matcher.rs       # 패턴 매칭 로직 (SIMD 가속)
│   ├── searcher.rs      # 단일 파일 검색
│   ├── search_dir.rs    # 디렉토리 전체 검색 (스트림)
│   ├── command.rs       # REPL 명령어 파싱
│   └── repls.rs         # REPL 인터페이스
├── example/             # 예제 코드
│   └── src/
│       ├── main.rs
│       └── channel_basic.rs
├── test_data/           # 테스트 데이터
│   ├── sample1.txt
│   ├── sample2.txt
│   └── subdir/
│       └── nested.txt
├── Cargo.toml           # 프로젝트 설정 및 의존성
└── readme.md            # 테스트 결과 문서
```

## 모듈 구조

### 1. `types.rs` - 타입 정의
**역할**: 검색 결과와 옵션을 담는 데이터 구조체 정의

**주요 타입**:
- `SearchOptions`: 검색 옵션 (대소문자 구분, 숨김 파일 포함 여부)
- `MatchInfo`: 검색 결과 정보
  - `path`: 파일 경로
  - `line_number`: 줄 번호 (1-based)
  - `column`: 컬럼 번호 (1-based)
  - `byte_offset`: 매치된 패턴의 바이트 오프셋
  - `matched_text`: 매치된 텍스트 (Arc<String>)
  - `line_range`: 줄의 시작/끝 바이트 범위

**메서드**:
- `make_pattern_link()`: `path:line:column` 형식 문자열 생성
- `make_location()`: `line:column` 형식 문자열 생성
- `get_line_text()`: 매치된 줄의 전체 텍스트 반환
- `highlighted_line()`: 하이라이트된 줄 텍스트 반환

### 2. `matcher.rs` - 패턴 매칭
**역할**: 바이트 배열에서 패턴 검색 및 줄 컨텍스트 추출

**함수**:
- `find_matches(target: &[u8], pattern: &[u8]) -> Vec<usize>`
  - `memmem::Finder`를 사용한 SIMD 가속 패턴 검색
  - 모든 매치 위치(바이트 오프셋) 반환
  
- `extract_line_context(data: &[u8], pos: usize) -> (usize, usize, (usize, usize))`
  - 매치 위치를 기준으로 줄 번호, 컬럼, 줄 범위 계산
  - `memchr`/`memrchr`로 줄 시작/끝 찾기
  - UTF-8 문자 수 기반 컬럼 계산

### 3. `searcher.rs` - 단일 파일 검색
**역할**: 하나의 파일에서 패턴을 검색하고 `MatchInfo` 벡터 반환

**함수**:
- `searcher(path: &Path, pattern: Arc<String>, options: &SearchOptions) -> Result<Vec<MatchInfo>>`
  - 메모리 매핑(`memmap2::Mmap`)으로 파일을 메모리에 로드
  - Zero-copy I/O로 성능 최적화
  - 빈 파일 체크
  - `matcher::find_matches()`로 매치 위치 찾기
  - 각 매치에 대해 `MatchInfo` 생성

### 4. `search_dir.rs` - 디렉토리 검색
**역할**: 디렉토리 전체를 병렬로 순회하며 검색 결과를 스트림으로 반환

**함수**:
- `search_stream(root: &Path, pattern: &str, options: SearchOptions) -> ReceiverStream<Result<MatchInfo>>`
  - `ignore::WalkBuilder`로 병렬 파일 순회 (ripgrep 기반)
  - CPU 코어 수만큼 스레드 생성
  - `tokio::sync::mpsc` 채널로 결과 스트리밍
  - 각 파일에 대해 `searcher::searcher()` 호출
  - 실시간 결과 전송 (Non-blocking)

**특징**:
- 백그라운드 스레드에서 실행 (`spawn_blocking`)
- 채널 버퍼 크기: 1000
- 숨김 파일 필터링 지원

### 5. `command.rs` - 명령어 파싱
**역할**: REPL 입력을 파싱하여 명령어로 변환

**타입**:
- `Command` enum:
  - `Search { pattern: String, path: String }`
  - `Quit`
  - `Help`
  - `Invalid(String)`

**함수**:
- `Command::parse(input: &str) -> Result<Self, String>`
  - 빈 입력 체크
  - 특수 명령어 처리 (`quit`, `help`)
  - 검색 명령어 파싱 (`pattern [path]`)

### 6. `repls.rs` - REPL 인터페이스
**역할**: 대화형 검색 인터페이스 제공

**함수**:
- `run_repl() -> async`
  - 무한 루프로 사용자 입력 대기
  - `Command::parse()`로 명령어 파싱
  - `search_stream()`로 검색 실행
  - 스트림에서 실시간 결과 출력
  - 결과 카운트 및 완료 메시지

**특징**:
- 비동기 스트림 처리 (`futures::StreamExt`)
- 실시간 결과 출력
- 에러 처리 및 사용자 피드백

### 7. `main.rs` - 프로그램 진입점
**역할**: 프로그램 실행 시작점

- `#[tokio::main]`으로 비동기 런타임 초기화
- `repls::run_repl().await` 호출

### 8. `lib.rs` - 라이브러리 진입점
**역할**: 외부에서 사용할 수 있는 공개 API 정의

**Export**:
- `MatchInfo`, `SearchOptions`
- `run_repl()`, `search_stream()`, `searcher()`

## 아키텍처 패턴

### 1. 계층 구조
```
REPL (repls.rs)
  ↓
Command Parser (command.rs)
  ↓
Directory Search (search_dir.rs)
  ↓
File Search (searcher.rs)
  ↓
Pattern Matcher (matcher.rs)
```

### 2. 데이터 흐름
```
사용자 입력 → Command 파싱 → search_stream() 생성
  ↓
백그라운드 스레드에서 파일 순회
  ↓
각 파일에 대해 searcher() 호출
  ↓
matcher로 패턴 검색
  ↓
MatchInfo 생성 → 채널로 전송
  ↓
REPL에서 스트림 소비 → 실시간 출력
```

### 3. 동시성 모델
- **비동기 런타임**: Tokio
- **병렬 파일 순회**: `ignore::WalkBuilder` (CPU 코어 수만큼 스레드)
- **스트림 통신**: `tokio::sync::mpsc` 채널
- **블로킹 I/O 격리**: `spawn_blocking`으로 파일 시스템 작업 분리

### 4. 성능 최적화
- **메모리 매핑**: `memmap2::Mmap`로 Zero-copy 파일 읽기
- **SIMD 가속**: `memchr`/`memmem`로 패턴 검색 최적화
- **병렬 처리**: 다중 스레드로 파일 순회
- **스트리밍**: 결과를 즉시 출력하여 지연 최소화

## 의존성

### 핵심 라이브러리
- `tokio`: 비동기 런타임
- `futures`: 스트림 트레이트
- `tokio-stream`: 스트림 유틸리티
- `ignore`: 병렬 파일 순회 (ripgrep 기반)
- `memmap2`: 메모리 매핑
- `memchr`: SIMD 가속 문자열 검색
- `anyhow`: 에러 처리
- `num_cpus`: CPU 코어 수 확인
- `bytecount`: 바이트 카운팅

### 유틸리티
- `walkdir`: 디렉토리 순회
- `colored`: 터미널 색상 출력
- `clap`: CLI 인자 파싱

## 사용 예시

### REPL 모드
```bash
$ cargo run
Code_Crush v0.1.0
사용법: <pattern> [path]
명령어: help, quit

> rust .
🔍 검색 시작: 'rust' in "."
test_data/sample1.txt:3:20  'rust'
test_data/sample1.txt:4:10  'rust'
...
✅ 완료: 총 7건 발견
```

### 라이브러리 사용
```rust
use search_core::{search_stream, SearchOptions};
use futures::StreamExt;

let mut stream = search_stream(
    Path::new("."),
    "pattern",
    SearchOptions::default()
);

while let Some(result) = stream.next().await {
    if let Ok(info) = result {
        println!("{}", info);
    }
}
```

## 테스트 데이터
- `test_data/sample1.txt`: 기본 테스트 케이스
- `test_data/sample2.txt`: 다중 매치 테스트
- `test_data/subdir/nested.txt`: 중첩 디렉토리 테스트

## 설계 원칙
1. **Zero-copy I/O**: 메모리 매핑으로 불필요한 복사 방지
2. **스트리밍**: 결과를 즉시 출력하여 사용자 경험 개선
3. **병렬 처리**: CPU 코어를 최대한 활용
4. **타입 안전성**: Rust의 타입 시스템으로 런타임 에러 방지
5. **에러 처리**: `anyhow::Result`로 명확한 에러 전파

## 향후 개선 사항
- [ ] 대소문자 무시 옵션 구현 (`case_insensitive`)
- [ ] 정규식 패턴 지원
- [ ] 파일 타입 필터링
- [ ] 결과 정렬 옵션
- [ ] 컨텍스트 라인 표시 옵션